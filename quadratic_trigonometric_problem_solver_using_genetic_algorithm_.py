# -*- coding: utf-8 -*-
"""Quadratic-Trigonometric Problem Solver Using Genetic Algorithm .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JAa7PswcTvONYyRX0dTRPzAcMuFpLF-z

# IMPORTED LIBRARY
"""

import random
import numpy as np
np.random.seed(1234)

"""# CONSTANTS AND GLOBAL VARIABLES"""

total_individual = 50
chromosome_length = 10
pc = 0.99
pm = 0.99
max_gen = 500
population = []
pool_filial = []
mutants = []

"""# 1ST GENERATION"""

def generate_chromosome(n):
	return np.random.randint(0,2,n)

"""# CHROMOSOME DECODING"""

def x1(chromosome):
	return (-1+(2-(-1)/(2**-1+2**-2+2**-3+2**-4+2**-5))*(chromosome[0]*2**-1 + chromosome[1]*2**-2 + chromosome[2]*2**-3 + chromosome[3]*2**-4 + chromosome[4]*2**-5))


def x2(chromosome):
	return (-1+(1-(-1)/(2**-1+2**-2+2**-3+2**-4+2**-5))*(chromosome[5]*2**-1 + chromosome[6]*2**-2 + chromosome[7]*2**-3 + chromosome[8]*2**-4 + chromosome[9]*2**-5))

"""# H FUNCTION"""

def h(x1,x2):
	return np.cos(x1)*np.sin(x2)-(x1/(x2**2+1))

"""# FITNESS FUNCTION"""

def fitness(chromosome):
	return (-h(x1(chromosome),x2(chromosome)))

"""# PARENTAL SELECTION"""

def parental_selection(pool):
  tournamently_selected = []
  total = 0
  for i in range(total_individual):
    total = total + fitness(pool[i])
  for j in range(total_individual):
    r = random.random()
    individual = 0
    while (r>0):
      r = r - fitness(pool[i])
      individual = individual + 1
      tournamently_selected.append(pool[individual])
  return tournamently_selected

"""# CROSSOVER"""

def crossover(selected1,selected2):
	n = np.random.randint(1,len(selected1))
	offspring1, offspring2 = [],[]
	for i in range(n):
		offspring1.append(selected1[i])
		offspring2.append(selected2[i])
	while(n<len(selected1)):
		offspring1.append(selected2[n])
		offspring2.append(selected1[n])
		n+=1
	return offspring1,offspring2

"""# MUTATION"""

def mutation(filial):
	mutant = filial
	r1 = np.random.random()
	if (r1<=pm):
		r2 = np.random.randint(0,len(filial))
		r3 = np.random.randint(0,2)
		mutant[r2] = r3
	return mutant

"""# SURVIVOR SELECTION"""

def survivor_selection(population1):
	generational_replacement = []
	next_gen = sorted(population1,key=fitness,reverse=True)
	for i in range(total_individual):
		generational_replacement.append(next_gen[i])
	return generational_replacement

"""# MAIN"""

for i in range(total_individual):
	population.append(generate_chromosome(chromosome_length))

for j in range(15):
	#parental_selection
  parent = parental_selection(population)

	#crossover
  k = 0
  while (k<total_individual):
    filial1, filial2 = crossover(parent[k],parent[k+1])
    pool_filial.append(filial1)
    pool_filial.append(filial2)
    k += 2

	#mutation
  for l in range(total_individual):
    mutants.append(mutation(pool_filial[l]))

	#survivor_selection
  generasi = population + mutants
  population = survivor_selection(generasi)
  elitism = max(population,key=fitness)

print("best solution     : ",elitism)
print("fitness score     : ",fitness(elitism))
print("x1                : ",x1(elitism))
print("x2                : ",x2(elitism))
print("function minimum  : ",h(x1(elitism),x2(elitism)))